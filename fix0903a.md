結論：だいたい合ってます！
その上で「確実に動く」ように、いくつか具体の直し方と落とし穴の回避を足します。

⸻

✅ 全体の方針 OK
	•	Phase 4 → 1 → 3 → 2 の順で進めるのは賢いです（まず通す→根治→自動化→長期最適化）。
	•	API URL をフロントのビルド時に焼き込む（.env.production or Cloud Buildで注入）は必須。
	•	API（Node/Express）の ESM/CJS 問題を先に安定化させるのも正解。

⸻

👇 ここをこう直す（具体例）

Phase 1: API（server.ts）を“確実に起動する”形へ

どちらかひとつに統一してください。

A) CommonJS に寄せる（一番安全）

api/package.json

{
  "type": "commonjs",               // ← もしくは丸ごと削除でもOK（既定はCJS）
  "scripts": {
    "build": "tsc -p .",
    "start": "node dist/server.js",
    "dev": "ts-node server.ts"
  }
}

tsconfig.json

{
  "compilerOptions": {
    "module": "CommonJS",
    "target": "ES2020",
    "outDir": "dist",
    "esModuleInterop": true,
    "strict": true
  }
}

これなら import に .js 追記は不要。型崩れが少なくトラブルも減ります。

B) ESM(NodeNext) を続ける（やるなら厳密に）

api/package.json

{ "type": "module", ... }

tsconfig.json

{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "outDir": "dist",
    "esModuleInterop": true,
    "strict": true
  }
}

	•	相対 import にはビルド後 .js 拡張子が必要になります（import './routes/review.js'）。
	•	これを忘れると Cloud Run 起動時に落ちやすいです。

迷ったら A: CommonJS が安定。

⸻

Phase 4: すぐ通すための一時措置（OK）

zine-app/lib/api.ts（例）

const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE ||
  'https://api-830716651527.asia-northeast1.run.app'; // 一時ハードコード

export async function novelize(body: any) {
  const r = await fetch(`${API_BASE}/novelize`, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(body)
  });
  if (!r.ok) throw new Error(`API ${r.status}`);
  return r.json();
}

CORS に当たったら API 側に cors() を入れて再デプロイするだけです。

⸻

Phase 3: cloudbuild.yaml で API→URL取得→フロント焼き込み→デプロイ（完成版）

リポ直下の cloudbuild.yaml 例（必要に応じて調整）

substitutions:
  _REGION: "asia-northeast1"
  _REPO: "zine-repo"
  _WEB_SERVICE: "web"
  _API_SERVICE: "api"

steps:
# 1) API を build & push
- name: gcr.io/cloud-builders/docker
  args: ["build","-t","${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_API_SERVICE}:$SHORT_SHA","api"]
- name: gcr.io/cloud-builders/docker
  args: ["push","${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_API_SERVICE}:$SHORT_SHA"]

# 2) API を Cloud Run にデプロイ（初回でもOK）
- name: gcr.io/google.com/cloudsdktool/cloud-sdk
  entrypoint: gcloud
  args:
    ["run","deploy","${_API_SERVICE}",
     "--image","${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_API_SERVICE}:$SHORT_SHA",
     "--region","${_REGION}",
     "--platform","managed",
     "--allow-unauthenticated",
     "--quiet"]

# 3) API の URL を取得して .env.production を生成（フロントに焼き込む）
- name: gcr.io/google.com/cloudsdktool/cloud-sdk
  entrypoint: bash
  args:
    - "-c"
    - |
      API_URL=$(gcloud run services describe ${_API_SERVICE} --region ${_REGION} --format="value(status.url)")
      echo "NEXT_PUBLIC_API_BASE=$API_URL" > zine-app/.env.production
      echo "Wrote zine-app/.env.production with $API_URL"

# 4) フロントを build & push （.env.production をバンドル）
- name: gcr.io/cloud-builders/docker
  args: ["build","-t","${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_WEB_SERVICE}:$SHORT_SHA","zine-app"]
- name: gcr.io/cloud-builders/docker
  args: ["push","${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_WEB_SERVICE}:$SHORT_SHA"]

# 5) フロントを Cloud Run にデプロイ
- name: gcr.io/google.com/cloudsdktool/cloud-sdk
  entrypoint: gcloud
  args:
    ["run","deploy","${_WEB_SERVICE}",
     "--image","${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_WEB_SERVICE}:$SHORT_SHA",
     "--region","${_REGION}",
     "--platform","managed",
     "--allow-unauthenticated",
     "--quiet"]

images:
- "${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_API_SERVICE}:$SHORT_SHA"
- "${_REGION}-docker.pkg.dev/$PROJECT_ID/${_REPO}/${_WEB_SERVICE}:$SHORT_SHA"

これで push だけで
①API→②URL取得→③フロントに埋め込み→④両方デプロイ まで一括自動化できます。

⸻

Phase 2: 「URLを固定にしたい」について
	•	Cloud Run のデフォルト URL は https://<service>-<HASH>-<region>.run.app。
サービス名とプロジェクト/リージョンが同じなら原則変わりません（HASH もサービス存続中は固定）。
	•	初回デプロイ後に その URL を .env.production に固定してもOK。
	•	もっと綺麗にするなら カスタムドメインを紐付けるのが理想。

⸻

よくある詰まりポイント（回避策）
	•	フロントで undefined/novelize → NEXT_PUBLIC_API_BASE が空でビルド済み。
⇒ .env.production を作って再ビルド。
	•	CORS → API に cors() を入れる（最初は origin: '*' でも良い。あとで絞る）。
	•	Cloud Run 起動時エラー（MODULE_NOT_FOUND 等） → ESM/CJS の不一致。
⇒ CommonJS に統一が安定。
	•	権限 → 実行 SA に roles/aiplatform.user（＋画像保存なら Storage の書込権限）。

⸻

進め方まとめ（あなたの順番でOK）
	1.	Phase 4：lib/api.ts に一時ハードコード → すぐ通るか確認
	2.	Phase 1：API を CJS で安定化、CORS 追加
	3.	Phase 3：cloudbuild.yaml を上記に差し替え（API→URL注入→WEB）
	4.	Phase 2：将来はドメイン/URL固定・ビルド設計を整理

これで、「小説化ボタン → /novelize → Vertex AI」 が確実に流れるようになります。
次に詰まったログやエラーが出たら、そのまま貼ってくれればピンポイントで直します！