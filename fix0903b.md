了解！チェックリストをそのまま「運用手順書」に落とし込みました。実装根拠は公式ドキュメント中心に添えてあります。

運用手順書（Next.js × Cloud Run × Cloud Build）

目的
	•	ビルド時に固定される NEXT_PUBLIC_* の挙動を踏まえ、
API → URL取得 → フロントへ注入 → フロントビルド → デプロイ の順で安定動作させる。  ￼

⸻

前提
	•	Cloud Run（API / Web）を Artifact Registry からデプロイ可能
	•	Cloud Build が gcloud を利用できる
	•	Vertex AI は Cloud Run の実行サービスアカウントで認証する（鍵ファイル不要）。  ￼

⸻

全体フロー（CI/CD）
	1.	APIをビルド＆デプロイ
	2.	gcloud run services describe で APIの実URL を取得
	3.	取得したURLを zine-app/.env.production の NEXT_PUBLIC_API_BASE に書き込み
	4.	その .env.production を取り込んで フロントをビルド＆デプロイ
	•	Cloud Run のサービスURLは 安定（run.appで不変）。注入後は再ビルドまで変わらない前提。  ￼

URL取得コマンド（Cloud Build内）

gcloud run services describe ${_API_SERVICE} \
  --region ${_REGION} \
  --format='value(status.url)'

（status.url の取り出しは公式CLIの標準手法）  ￼ ￼

⸻

手順

1. APIサービス側の安定化
	•	TypeScriptのESMインポートを維持しつつ、出力はCommonJSに設定（tsconfig.json: "module": "CommonJS"）。
	•	互換性のため esModuleInterop を有効化推奨。  ￼ ￼

2. Cloud Run（API）の公開設定
	•	フロントから直接叩く場合は Unauthenticated 許可（allUsers に Cloud Run Invoker 付与）。
GUI/CLIいずれでも可。  ￼

3. Cloud Build の実行順序
	•	API → URL取得 → .env.production 生成 → Webビルド → Webデプロイ
	•	.env.production の中身は NEXT_PUBLIC_API_BASE={API_URL} の1行のみでOK。
注: .env をコンテナに焼き込む設計は基本非推奨（秘匿値は特に）。今回は**公開値（URL）**なので許容だが、設計方針は把握しておくこと。  ￼ ￼

4. フロントの実装統一
	•	暫定ハードコードは撤去し、process.env.NEXT_PUBLIC_API_BASE のみを参照。
	•	NEXT_PUBLIC_* はビルド時にバンドルへ埋め込まれる点を再確認。  ￼ ￼ ￼

5. Vertex AI の実行権限
	•	Cloud Run の実行サービスアカウントに Vertex AI / 必要なGCS 権限を付与。
	•	GCP上では ワークロードID（SA添付）認証が標準・推奨。  ￼

⸻

検証・運用チェックリスト

デプロイ直後（自動/E2E）
	•	API_URL/healthz が 200（Cloud Buildの post-deploy テストでも可）
	•	フロントから fetch(NEXT_PUBLIC_API_BASE + ...) が成功
	•	WebとAPIの Cloud Run リビジョンが最新を指す

障害時の切り戻し
	•	Cloud Run はリビジョンを保持 → トラフィックスプリットで即時ロールバック可能
	•	.env.production を再生成して再ビルド（URL変更や設定齟齬時）

⸻

よくある落とし穴（再発防止）
	•	デプロイ後に環境変数を変えても NEXT_PUBLIC_* は反映されない
→ 必ず再ビルドが必要。  ￼
	•	APIを 認証必須のまま にしてフロントからCORS/401になる
→ Unauthenticated許可を付与、CORS設定も確認。  ￼
	•	Vertex AI が 認証エラー（ローカルはよく起きる）
→ 本番は Cloud Run の SA で動作。権限不足をIAMで解消。  ￼

⸻

参考（一次情報）
	•	Next.js の環境変数（NEXT_PUBLIC_* はビルド時にバンドル）  ￼
	•	Cloud Run サービスURLの取得（status.url）  ￼ ￼
	•	Cloud Run を一般公開（Unauthenticated）にする手順  ￼
	•	Vertex AI のワークロード認証（サービスアカウント添付）  ￼
	•	TypeScript と CJS/ESM の実務的整理（esModuleInterop 等）  ￼ ￼

⸻

必要なら、これをそのまま fix0903a.md に追記する形で完成版ドキュメントに整えてお渡しします。

⸻

# ZINE作成機能改善プラン（2025-09-03追加）

## 改善対象の問題点

### 1. 小説モードの戻るボタンの動作修正
**問題**: 小説モードで「戻る」ボタンを押すとホーム画面に戻ってしまう  
**現状**: `onBack()` 関数が直接呼ばれてホーム画面へ遷移  
**修正**: `mode === "novel"` の場合は `setMode("zine")` でZINE作成画面に戻るように変更

### 2. ZINE作成での複数ページ対応とページ操作UI
**問題**: 現在は単一ページ（見開き）のみで複数ページ作成ができない  
**現状**: `currentPageIndex` 状態とページ配列は存在するが、UI上でページ切り替えができない  
**修正**: 
- ページナビゲーション（前/次ページボタン）をヘッダー部分に追加
- ページ番号表示とページ追加ボタンを実装
- `currentPageIndex` を使用してページ切り替え機能を実装

### 3. 小説モードでの両ページ表示と複数ページ対応
**問題**: 
- 左ページにAI生成コンテンツ、右ページに固定サンプルテキストが表示される
- 小説モードでも単一見開きのみで複数ページ対応していない  

**現状コード分析**:
- 左ページ（2028行）: `novelContent` を表示（AIコンテンツ）
- 右ページ（2052行）: 固定テキストを表示

**修正**:
- `novelContent` を文字数で自動分割し、両ページに適切に配分
- 小説モード専用のページ状態 `novelPages` を新設
- ページ送り機能で長い小説を複数ページで表示可能にする

## 実装手順

1. **戻るボタンロジック修正** (zine-creator.tsx 1633行付近)
   ```typescript
   // 修正前
   <Button onClick={onBack}>戻る</Button>
   
   // 修正後  
   <Button onClick={mode === "novel" ? () => setMode("zine") : onBack}>
     戻る
   </Button>
   ```

2. **ページナビゲーションUI追加** (ヘッダー部分に追加)
   - 前ページ/次ページボタン
   - 現在ページ表示 「ページ X / Y」
   - 新規ページ追加ボタン

3. **小説モード用のページシステム実装**
   - `novelPages` 状態を新設
   - テキスト自動分割関数 `splitNovelContent()` を実装
   - 小説モード用のページナビゲーション機能

4. **テキスト分割ロジック**
   - 1ページあたりの文字数制限を設定（例：800文字/ページ）
   - 段落の境界で自然に分割
   - 両ページに均等に文字を配分

## 影響範囲
- `zine-creator.tsx` の修正のみ
- 既存の状態管理を活用し、大きな構造変更は不要
- API連携部分に変更なし

## 実装進捗
- [x] 戻るボタンロジック修正 (完了 - 小説モードからZINE作成に戻るように修正)
- [x] ページナビゲーションUI追加 (完了 - ZINE・小説両モードでページナビゲーション実装)
- [x] 小説モードの両ページ表示と複数ページ対応 (完了 - テキスト自動分割と見開きページ表示)

## 実装完了内容

### 1. 戻るボタン修正
- `onClick={mode === "novel" ? () => setMode("zine") : onBack}` を実装
- 小説モードでは ZINE 作成画面に戻り、ZINE モードではホームに戻る

### 2. ページナビゲーション UI
- ZINEモード: 前/次ページボタン、ページ番号表示、新規ページ追加ボタン
- 小説モード: 見開きページナビゲーション（左右ページを1つの見開きとしてカウント）
- ヘッダー中央にページナビゲーションを配置

### 3. 小説モード改善
- `splitNovelContent()` 関数で800文字/ページに自動分割
- `novelPages` 状態で分割されたページを管理
- 左ページ: `novelPages[(currentNovelPage - 1) * 2]`
- 右ページ: `novelPages[(currentNovelPage - 1) * 2 + 1]`
- ページ番号を動的に表示（左ページ: N*2, 右ページ: N*2+1）

### 4. 技術的実装詳細
- 必要なアイコン追加: `ChevronLeft`, `ChevronRight`, `Plus`
- 新しい状態変数: `novelPages: string[]`
- ページ分割は段落区切り(`\n\n`)を考慮して自然に分割
- AI生成後に`setNovelPages()`で自動的にページ分割処理